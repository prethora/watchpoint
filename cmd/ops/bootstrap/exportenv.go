package main

import (
	"context"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

// ssmToEnvMapping maps SSM category/key paths to the environment variable
// names expected by the application configuration (03-config.md Section 3).
//
// This mapping bridges the gap between SSM parameter names (used during
// bootstrap) and the environment variable names consumed by the config
// loader via envconfig tags. For local development, secrets are resolved
// directly from the .env file rather than through SSM indirection.
//
// The keys are the SSM category/key portions (e.g., "database/url") that
// match BootstrapStep.SSMCategoryKey. The values are the environment
// variable names from the envconfig struct tags in internal/config/config.go.
var ssmToEnvMapping = map[string]string{
	// Database
	"database/url": "DATABASE_URL",

	// Billing (03-config.md Section 2.2 BillingConfig)
	"billing/stripe_secret_key":      "STRIPE_SECRET_KEY",
	"billing/stripe_publishable_key": "STRIPE_PUBLISHABLE_KEY",

	// Email (03-config.md Section 2.2 EmailConfig)
	"email/sendgrid_api_key": "SENDGRID_API_KEY",

	// Forecast (03-config.md Section 2.2 ForecastConfig)
	"forecast/runpod_api_key":     "RUNPOD_API_KEY",
	"forecast/runpod_endpoint_id": "RUNPOD_ENDPOINT_ID",

	// Auth (03-config.md Section 2.2 AuthConfig)
	"auth/google_client_id": "GOOGLE_CLIENT_ID",
	"auth/google_secret":    "GOOGLE_CLIENT_SECRET",
	"auth/github_client_id": "GITHUB_CLIENT_ID",
	"auth/github_secret":    "GITHUB_CLIENT_SECRET",
	"auth/session_key":      "SESSION_KEY",

	// Security (03-config.md Section 2.2 SecurityConfig)
	"security/admin_api_key": "ADMIN_API_KEY",
}

// envFileHeader is the comment header written at the top of the generated
// .env file to identify it as machine-generated.
const envFileHeader = `# WatchPoint Environment Configuration
#
# Auto-generated by bootstrap --export-env
# Generated: %s
# Environment: %s
#
# This file maps SSM parameters to the environment variables expected by
# the WatchPoint application (see architecture/03-config.md).
#
# SECURITY WARNING: This file contains secrets. Do not commit to version control.
# It is already listed in .gitignore.
#
# For local development with docker-compose, this file is loaded automatically.
# For cloud deployments, secrets are resolved via SSM Parameter Store.
`

// localDevDefaults provides additional environment variables needed for local
// development that are not stored in SSM. These complement the SSM-sourced
// secrets with the infrastructure configuration that the .env.example provides.
//
// These are written to the .env file after the SSM-sourced values to create
// a complete local development configuration.
var localDevDefaults = map[string]string{
	"APP_ENV":                "local",
	"LOG_LEVEL":              "debug",
	"OTEL_SERVICE_NAME":      "watchpoint-service",
	"IS_TEST_MODE":           "false",
	"PORT":                   "8080",
	"API_EXTERNAL_URL":       "http://localhost:8080",
	"DASHBOARD_URL":          "http://localhost:3000",
	"AWS_ENDPOINT_URL":       "http://localhost:9000",
	"AWS_REGION":             "us-east-1",
	"AWS_ACCESS_KEY_ID":      "minioadmin",
	"AWS_SECRET_ACCESS_KEY":  "minioadmin",
	"FORECAST_BUCKET":        "watchpoint-forecasts",
	"ARCHIVE_BUCKET":         "watchpoint-archive",
	"SQS_EVAL_URGENT":        "http://localhost:4566/000000000000/eval-queue-urgent",
	"SQS_EVAL_STANDARD":      "http://localhost:4566/000000000000/eval-queue-standard",
	"SQS_NOTIFICATIONS":      "http://localhost:4566/000000000000/notification-queue",
	"SQS_DLQ":                "http://localhost:4566/000000000000/dead-letter-queue-shared",
	"EMAIL_FROM_ADDRESS":     "alerts@watchpoint.io",
	"EMAIL_FROM_NAME":        "WatchPoint Alerts",
	"EMAIL_PROVIDER":         "sendgrid",
	"EMAIL_TEMPLATES_JSON":   `{"default":{"threshold_crossed":"d-template-001","alert_resolved":"d-template-002"}}`,
	"CORS_ALLOWED_ORIGINS":   "*",
	"METRIC_NAMESPACE":       "WatchPoint",
	"ENABLE_TRACING":         "false",
	"WEBHOOK_USER_AGENT":     "WatchPoint-Webhook/1.0",
	"WEBHOOK_TIMEOUT":        "10s",
	"WEBHOOK_MAX_REDIRECTS":  "3",
	"FEATURE_ENABLE_NOWCAST": "true",
	"FEATURE_ENABLE_EMAIL":   "true",

	// STRIPE_WEBHOOK_SECRET is required by the config (validate:"required")
	// but is not in the bootstrap inventory because it is generated by Stripe
	// during webhook registration in Phase 5 (Post-Deployment Wiring).
	// A dummy value is provided here for local development.
	"STRIPE_WEBHOOK_SECRET": "whsec_local_dummy_stripe_webhook_secret",
}

// ExportEnvConfig holds the configuration for the env file export operation.
type ExportEnvConfig struct {
	// OutputPath is the file path where the .env file will be written.
	// Defaults to ".env" in the project root.
	OutputPath string

	// Environment is the bootstrap environment (dev/staging/prod).
	Environment string

	// SSM is the SSM manager used to read parameter values.
	SSM *SSMManager

	// Stderr is where progress messages are written.
	Stderr io.Writer

	// IncludeLocalDefaults controls whether non-SSM local development
	// defaults (like APP_ENV=local, LocalStack URLs, etc.) are included
	// in the output. When true, the generated .env file is a complete
	// local development configuration.
	IncludeLocalDefaults bool
}

// ExportEnvFile reads all bootstrap parameters from SSM Parameter Store,
// maps them to their corresponding environment variable names, and writes
// them to a .env file suitable for local development with docker-compose.
//
// This function is called after a successful bootstrap run when the
// --export-env flag is set. It creates a bridge between the bootstrap
// phase (which populates SSM) and Phase 9 (Local Integration Verification),
// which requires a .env file.
//
// Security note: SecureString parameters are decrypted by the SSM API
// (WithDecryption=true) and written to the .env file in plaintext. The
// file permissions are set to 0600 (owner read/write only) to minimize
// exposure.
func ExportEnvFile(ctx context.Context, cfg ExportEnvConfig) error {
	inventory := BuildInventory(NewValidatorWithDeps(nil, nil))

	var lines []string

	// Collect values from SSM for each inventory step.
	var written int
	var skipped int
	for _, step := range inventory {
		envVar, ok := ssmToEnvMapping[step.SSMCategoryKey]
		if !ok {
			fmt.Fprintf(cfg.Stderr, "  Warning: no env var mapping for SSM key %q, skipping\n", step.SSMCategoryKey)
			skipped++
			continue
		}

		path := cfg.SSM.SSMPath(step.SSMCategoryKey)

		value, err := cfg.SSM.GetParameterValue(ctx, path, step.ParamType == ParamSecureString)
		if err != nil {
			fmt.Fprintf(cfg.Stderr, "  Warning: could not read %s (%s): %v\n", step.HumanLabel, path, err)
			skipped++
			continue
		}

		lines = append(lines, formatEnvLine(envVar, value))
		written++
	}

	if written == 0 {
		return fmt.Errorf("no parameters could be read from SSM; .env file not written")
	}

	// Build the complete file content.
	var buf strings.Builder

	// Write the header.
	fmt.Fprintf(&buf, envFileHeader, time.Now().UTC().Format(time.RFC3339), cfg.Environment)
	buf.WriteString("\n")

	// Write SSM-sourced values.
	buf.WriteString("# =============================================================================\n")
	buf.WriteString("# Secrets (from SSM Parameter Store)\n")
	buf.WriteString("# =============================================================================\n")
	for _, line := range lines {
		buf.WriteString(line)
		buf.WriteString("\n")
	}

	// Write local development defaults if requested.
	if cfg.IncludeLocalDefaults {
		buf.WriteString("\n")
		buf.WriteString("# =============================================================================\n")
		buf.WriteString("# Local Development Defaults\n")
		buf.WriteString("# =============================================================================\n")

		// Sort keys for deterministic output.
		keys := make([]string, 0, len(localDevDefaults))
		for k := range localDevDefaults {
			keys = append(keys, k)
		}
		sort.Strings(keys)

		// Only write defaults that were NOT already written from SSM
		// (SSM values take precedence).
		ssmVars := make(map[string]bool)
		for _, envVar := range ssmToEnvMapping {
			ssmVars[envVar] = true
		}

		for _, key := range keys {
			if ssmVars[key] {
				continue // already provided by SSM
			}
			buf.WriteString(formatEnvLine(key, localDevDefaults[key]))
			buf.WriteString("\n")
		}
	}

	// Write the file with restricted permissions (0600: owner read/write only).
	outputPath := cfg.OutputPath
	if outputPath == "" {
		outputPath = ".env"
	}

	// Ensure the parent directory exists.
	dir := filepath.Dir(outputPath)
	if dir != "." && dir != "" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("creating directory %s: %w", dir, err)
		}
	}

	if err := os.WriteFile(outputPath, []byte(buf.String()), 0600); err != nil {
		return fmt.Errorf("writing .env file to %s: %w", outputPath, err)
	}

	fmt.Fprintf(cfg.Stderr, "\n")
	fmt.Fprintf(cfg.Stderr, "------------------------------------------------------------\n")
	fmt.Fprintf(cfg.Stderr, "  Environment file exported: %s\n", outputPath)
	fmt.Fprintf(cfg.Stderr, "  Parameters written: %d | Skipped: %d\n", written, skipped)
	if cfg.IncludeLocalDefaults {
		fmt.Fprintf(cfg.Stderr, "  Local development defaults: included\n")
	}
	fmt.Fprintf(cfg.Stderr, "  File permissions: 0600 (owner read/write only)\n")
	fmt.Fprintf(cfg.Stderr, "------------------------------------------------------------\n")

	return nil
}

// formatEnvLine formats a key=value pair for a .env file. Values containing
// special characters (spaces, quotes, #, newlines) are wrapped in double
// quotes with appropriate escaping.
func formatEnvLine(key, value string) string {
	// Determine if the value needs quoting. Values with spaces, quotes,
	// hash signs, or special characters must be quoted.
	needsQuote := false
	if strings.ContainsAny(value, " \t\n\r\"'#$\\{}") {
		needsQuote = true
	}
	// Empty values should also be quoted for clarity.
	if value == "" {
		needsQuote = true
	}

	if !needsQuote {
		return key + "=" + value
	}

	// Escape backslashes, double quotes, and newlines within the value.
	escaped := strings.ReplaceAll(value, `\`, `\\`)
	escaped = strings.ReplaceAll(escaped, `"`, `\"`)
	escaped = strings.ReplaceAll(escaped, "\n", `\n`)
	escaped = strings.ReplaceAll(escaped, "\r", `\r`)

	return key + `="` + escaped + `"`
}
