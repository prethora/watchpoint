package db

import (
	"context"
	"errors"
	"time"

	"github.com/jackc/pgx/v5"

	"watchpoint/internal/types"
)

// SessionRepository provides data access for the sessions table.
// It implements the session management operations required by SessionService
// and other components that need to invalidate sessions (e.g., UserHandler).
type SessionRepository struct {
	db DBTX
}

// NewSessionRepository creates a new SessionRepository backed by the given
// database connection (pool or transaction).
func NewSessionRepository(db DBTX) *SessionRepository {
	return &SessionRepository{db: db}
}

// Create inserts a new session record into the sessions table.
// The session ID and CSRF token must be pre-generated by the caller.
func (r *SessionRepository) Create(ctx context.Context, session *types.Session) error {
	_, err := r.db.Exec(ctx,
		`INSERT INTO sessions (id, user_id, organization_id, csrf_token, ip_address, user_agent, expires_at, last_activity_at, created_at)
		 VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,
		session.ID,
		session.UserID,
		session.OrganizationID,
		session.CSRFToken,
		session.IPAddress,
		session.UserAgent,
		session.ExpiresAt,
		session.LastActivityAt,
		session.CreatedAt,
	)
	if err != nil {
		return types.NewAppError(types.ErrCodeInternalDB, "failed to create session", err)
	}
	return nil
}

// GetByID retrieves a session by its ID. Returns an AppError with
// ErrCodeAuthSessionExpired if the session does not exist (which covers
// both "not found" and "expired then deleted" cases from the caller's
// perspective).
func (r *SessionRepository) GetByID(ctx context.Context, sessionID string) (*types.Session, error) {
	row := r.db.QueryRow(ctx,
		`SELECT id, user_id, organization_id, csrf_token, ip_address, user_agent, expires_at, last_activity_at, created_at
		 FROM sessions
		 WHERE id = $1`,
		sessionID,
	)

	var s types.Session
	err := row.Scan(
		&s.ID,
		&s.UserID,
		&s.OrganizationID,
		&s.CSRFToken,
		&s.IPAddress,
		&s.UserAgent,
		&s.ExpiresAt,
		&s.LastActivityAt,
		&s.CreatedAt,
	)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, types.NewAppError(types.ErrCodeAuthSessionExpired, "session not found or expired", nil)
		}
		return nil, types.NewAppError(types.ErrCodeInternalDB, "failed to retrieve session", err)
	}
	return &s, nil
}

// DeleteByID performs a hard delete of a single session (used for logout).
// Per the architecture (Section 7.2): "DELETE FROM sessions WHERE id = $1"
// to ensure immediate invalidation.
func (r *SessionRepository) DeleteByID(ctx context.Context, sessionID string) error {
	_, err := r.db.Exec(ctx,
		`DELETE FROM sessions WHERE id = $1`,
		sessionID,
	)
	if err != nil {
		return types.NewAppError(types.ErrCodeInternalDB, "failed to delete session", err)
	}
	return nil
}

// DeleteByUser removes all active sessions for a specific user ID.
// Used during password reset to immediately revoke all access (Section 7.2)
// and by UserHandler for session invalidation on user deletion/block.
func (r *SessionRepository) DeleteByUser(ctx context.Context, userID string) error {
	_, err := r.db.Exec(ctx,
		`DELETE FROM sessions WHERE user_id = $1`,
		userID,
	)
	if err != nil {
		return types.NewAppError(types.ErrCodeInternalDB, "failed to delete user sessions", err)
	}
	return nil
}

// DeleteExpiredByUser removes expired sessions for a specific user.
// This is the "lazy session cleanup" called during login transactions
// to prevent table bloat (DASH-001 flow simulation).
func (r *SessionRepository) DeleteExpiredByUser(ctx context.Context, userID string) error {
	_, err := r.db.Exec(ctx,
		`DELETE FROM sessions WHERE user_id = $1 AND expires_at < NOW()`,
		userID,
	)
	if err != nil {
		return types.NewAppError(types.ErrCodeInternalDB, "failed to cleanup expired sessions", err)
	}
	return nil
}

// UpdateActivity updates the last_activity_at and expires_at for a session.
// Used by the sliding window session refresh (DASH-003). The update is
// conditional on last_activity_at being older than the staleness threshold
// to avoid unnecessary writes on every request.
func (r *SessionRepository) UpdateActivity(ctx context.Context, sessionID string, newExpiry time.Time, stalenessCutoff time.Time) (bool, error) {
	tag, err := r.db.Exec(ctx,
		`UPDATE sessions
		 SET last_activity_at = NOW(), expires_at = $1
		 WHERE id = $2
		   AND last_activity_at < $3`,
		newExpiry,
		sessionID,
		stalenessCutoff,
	)
	if err != nil {
		return false, types.NewAppError(types.ErrCodeInternalDB, "failed to update session activity", err)
	}
	return tag.RowsAffected() > 0, nil
}
