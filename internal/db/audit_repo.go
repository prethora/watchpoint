package db

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/jackc/pgx/v5"

	"watchpoint/internal/types"
)

// AuditRepository provides data access for the audit_log table.
// It implements the AuditRepository interface defined in 02-foundation-db.md
// Section 9.2. Audit events are append-only records of actions taken on
// resources within an organization.
type AuditRepository struct {
	db DBTX
}

// NewAuditRepository creates a new AuditRepository backed by the given
// database connection (pool or transaction).
func NewAuditRepository(db DBTX) *AuditRepository {
	return &AuditRepository{db: db}
}

// Log inserts a new audit log entry. The ID is auto-generated by the database
// if the entry's ID is empty. The ip_address is set to NULL since it is not
// part of the AuditEvent struct; the handler layer may add IP logging via a
// separate mechanism if needed.
func (r *AuditRepository) Log(ctx context.Context, entry *types.AuditEvent) error {
	// Marshal old_value and new_value to JSON if present.
	var oldValue, newValue []byte
	var err error

	if entry.OldValue != nil {
		oldValue = entry.OldValue
	}
	if entry.NewValue != nil {
		newValue = entry.NewValue
	}

	if entry.ID != "" {
		// Caller provided an ID; use it directly.
		_, err = r.db.Exec(ctx,
			`INSERT INTO audit_log (id, organization_id, actor_id, actor_type,
			 action, resource_type, resource_id, old_value, new_value, created_at)
			 VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, COALESCE($10, NOW()))`,
			entry.ID,
			entry.Actor.OrganizationID,
			entry.Actor.ID,
			string(entry.Actor.Type),
			entry.Action,
			entry.ResourceType,
			entry.ResourceID,
			nilIfEmptyJSON(oldValue),
			nilIfEmptyJSON(newValue),
			nilIfZeroTime(entry.Timestamp),
		)
	} else {
		// Let the database generate the ID via DEFAULT.
		_, err = r.db.Exec(ctx,
			`INSERT INTO audit_log (organization_id, actor_id, actor_type,
			 action, resource_type, resource_id, old_value, new_value, created_at)
			 VALUES ($1, $2, $3, $4, $5, $6, $7, $8, COALESCE($9, NOW()))`,
			entry.Actor.OrganizationID,
			entry.Actor.ID,
			string(entry.Actor.Type),
			entry.Action,
			entry.ResourceType,
			entry.ResourceID,
			nilIfEmptyJSON(oldValue),
			nilIfEmptyJSON(newValue),
			nilIfZeroTime(entry.Timestamp),
		)
	}
	if err != nil {
		return types.NewAppError(types.ErrCodeInternalDB, "failed to write audit log entry", err)
	}
	return nil
}

// List retrieves audit log entries matching the given filters with cursor-based
// pagination. Results are ordered by created_at DESC (newest first).
//
// Pagination uses created_at as the cursor value. The cursor is the created_at
// timestamp of the last item in the previous page (ISO 8601 format).
//
// As shown in the OBS-011 flow simulation: the query fetches limit+1 rows to
// determine if more pages exist.
func (r *AuditRepository) List(ctx context.Context, params types.AuditQueryFilters) ([]*types.AuditEvent, types.PageInfo, error) {
	// Default limit if not set
	limit := params.Limit
	if limit <= 0 {
		limit = 20
	}

	// Build the query dynamically based on provided filters.
	var conditions []string
	var args []any
	argIdx := 1

	// Organization ID is always required for scoped queries.
	conditions = append(conditions, fmt.Sprintf("organization_id = $%d", argIdx))
	args = append(args, params.OrganizationID)
	argIdx++

	if params.ActorID != "" {
		conditions = append(conditions, fmt.Sprintf("actor_id = $%d", argIdx))
		args = append(args, params.ActorID)
		argIdx++
	}

	if params.ResourceType != "" {
		conditions = append(conditions, fmt.Sprintf("resource_type = $%d", argIdx))
		args = append(args, params.ResourceType)
		argIdx++
	}

	if !params.StartTime.IsZero() {
		conditions = append(conditions, fmt.Sprintf("created_at >= $%d", argIdx))
		args = append(args, params.StartTime)
		argIdx++
	}

	if !params.EndTime.IsZero() {
		conditions = append(conditions, fmt.Sprintf("created_at <= $%d", argIdx))
		args = append(args, params.EndTime)
		argIdx++
	}

	// Cursor-based pagination: fetch entries older than the cursor timestamp.
	if params.Cursor != "" {
		cursorTime, err := time.Parse(time.RFC3339Nano, params.Cursor)
		if err != nil {
			return nil, types.PageInfo{}, types.NewAppError(
				types.ErrCodeValidationMissingField,
				"invalid cursor format; expected RFC3339 timestamp",
				err,
			)
		}
		conditions = append(conditions, fmt.Sprintf("created_at < $%d", argIdx))
		args = append(args, cursorTime)
		argIdx++
	}

	whereClause := "WHERE " + strings.Join(conditions, " AND ")

	// Fetch limit+1 to detect if there are more results.
	query := fmt.Sprintf(
		`SELECT id, organization_id, actor_id, actor_type, action,
		        resource_type, resource_id, old_value, new_value, created_at
		 FROM audit_log
		 %s
		 ORDER BY created_at DESC
		 LIMIT $%d`,
		whereClause,
		argIdx,
	)
	args = append(args, limit+1)

	rows, err := r.db.Query(ctx, query, args...)
	if err != nil {
		return nil, types.PageInfo{}, types.NewAppError(types.ErrCodeInternalDB, "failed to query audit log", err)
	}
	defer rows.Close()

	var results []*types.AuditEvent
	for rows.Next() {
		event, scanErr := scanAuditEvent(rows)
		if scanErr != nil {
			return nil, types.PageInfo{}, types.NewAppError(types.ErrCodeInternalDB, "failed to scan audit log row", scanErr)
		}
		results = append(results, event)
	}
	if err := rows.Err(); err != nil {
		return nil, types.PageInfo{}, types.NewAppError(types.ErrCodeInternalDB, "error iterating audit log rows", err)
	}

	// Determine pagination info.
	pageInfo := types.PageInfo{}
	if len(results) > limit {
		pageInfo.HasMore = true
		// The cursor is the created_at of the last item we will return.
		pageInfo.NextCursor = results[limit-1].Timestamp.Format(time.RFC3339Nano)
		results = results[:limit] // Trim the extra row
	}

	return results, pageInfo, nil
}

// ListOlderThan retrieves audit events older than the cutoff time for archival.
// Used by ArchiveAuditLogs to fetch records before uploading to cold storage
// (MAINT-004).
func (r *AuditRepository) ListOlderThan(ctx context.Context, cutoff time.Time, limit int) ([]*types.AuditEvent, error) {
	if limit <= 0 {
		limit = 1000
	}

	rows, err := r.db.Query(ctx,
		`SELECT id, organization_id, actor_id, actor_type, action,
		        resource_type, resource_id, old_value, new_value, created_at
		 FROM audit_log
		 WHERE created_at < $1
		 ORDER BY created_at ASC
		 LIMIT $2`,
		cutoff,
		limit,
	)
	if err != nil {
		return nil, types.NewAppError(types.ErrCodeInternalDB, "failed to query old audit log entries", err)
	}
	defer rows.Close()

	var results []*types.AuditEvent
	for rows.Next() {
		event, scanErr := scanAuditEvent(rows)
		if scanErr != nil {
			return nil, types.NewAppError(types.ErrCodeInternalDB, "failed to scan old audit log row", scanErr)
		}
		results = append(results, event)
	}
	if err := rows.Err(); err != nil {
		return nil, types.NewAppError(types.ErrCodeInternalDB, "error iterating old audit log rows", err)
	}

	return results, nil
}

// DeleteIDs hard-deletes audit records by ID after successful archival to S3.
// Used as part of the fetch-upload-delete cycle in ArchiveAuditLogs.
func (r *AuditRepository) DeleteIDs(ctx context.Context, ids []string) error {
	if len(ids) == 0 {
		return nil
	}

	_, err := r.db.Exec(ctx,
		`DELETE FROM audit_log WHERE id = ANY($1)`,
		ids,
	)
	if err != nil {
		return types.NewAppError(types.ErrCodeInternalDB, "failed to delete audit log entries", err)
	}
	return nil
}

// scanAuditEvent scans a single audit log row from pgx.Rows into an AuditEvent.
// The column order must match: id, organization_id, actor_id, actor_type,
// action, resource_type, resource_id, old_value, new_value, created_at.
func scanAuditEvent(rows pgx.Rows) (*types.AuditEvent, error) {
	var (
		event          types.AuditEvent
		organizationID string
		actorID        string
		actorType      string
		oldValue       []byte
		newValue       []byte
	)

	err := rows.Scan(
		&event.ID,
		&organizationID,
		&actorID,
		&actorType,
		&event.Action,
		&event.ResourceType,
		&event.ResourceID,
		&oldValue,
		&newValue,
		&event.Timestamp,
	)
	if err != nil {
		return nil, err
	}

	event.Actor = types.Actor{
		ID:             actorID,
		Type:           types.ActorType(actorType),
		OrganizationID: organizationID,
	}

	if oldValue != nil {
		event.OldValue = json.RawMessage(oldValue)
	}
	if newValue != nil {
		event.NewValue = json.RawMessage(newValue)
	}

	return &event, nil
}

// nilIfEmptyJSON returns nil if the byte slice is nil or empty, otherwise
// returns the slice unchanged. Used for nullable JSONB columns.
func nilIfEmptyJSON(b []byte) []byte {
	if len(b) == 0 {
		return nil
	}
	return b
}
