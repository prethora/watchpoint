package db

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"

	"watchpoint/internal/types"
)

// ForecastRunRepository provides data access for the forecast_runs table.
// It implements the ForecastRunRepository interface defined in 02-foundation-db.md
// Section 9.2. Forecast runs track the execution and status of model inference
// jobs (medium_range, nowcast).
type ForecastRunRepository struct {
	db DBTX
}

// NewForecastRunRepository creates a new ForecastRunRepository backed by the
// given database connection (pool or transaction).
func NewForecastRunRepository(db DBTX) *ForecastRunRepository {
	return &ForecastRunRepository{db: db}
}

// Create inserts a new forecast run record. The ID is auto-generated by the
// database if the run's ID is empty. The caller must provide model,
// run_timestamp, source_data_timestamp, storage_path, and status at minimum.
func (r *ForecastRunRepository) Create(ctx context.Context, run *types.ForecastRun) error {
	if run.ID != "" {
		_, err := r.db.Exec(ctx,
			`INSERT INTO forecast_runs
			 (id, model, run_timestamp, source_data_timestamp, storage_path, status,
			  external_id, retry_count, failure_reason, inference_duration_ms, created_at)
			 VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, COALESCE($11, NOW()))`,
			run.ID,
			string(run.Model),
			run.RunTimestamp,
			run.SourceDataTimestamp,
			run.StoragePath,
			run.Status,
			nilIfEmpty(run.ExternalID),
			run.RetryCount,
			nilIfEmpty(run.FailureReason),
			nilIfZeroInt(run.DurationMS),
			nilIfZeroTime(run.CreatedAt),
		)
		if err != nil {
			return types.NewAppError(types.ErrCodeInternalDB, "failed to create forecast run", err)
		}
		return nil
	}

	// Let the database generate the ID via DEFAULT.
	row := r.db.QueryRow(ctx,
		`INSERT INTO forecast_runs
		 (model, run_timestamp, source_data_timestamp, storage_path, status,
		  external_id, retry_count, failure_reason, inference_duration_ms, created_at)
		 VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, COALESCE($10, NOW()))
		 RETURNING id, created_at`,
		string(run.Model),
		run.RunTimestamp,
		run.SourceDataTimestamp,
		run.StoragePath,
		run.Status,
		nilIfEmpty(run.ExternalID),
		run.RetryCount,
		nilIfEmpty(run.FailureReason),
		nilIfZeroInt(run.DurationMS),
		nilIfZeroTime(run.CreatedAt),
	)
	if err := row.Scan(&run.ID, &run.CreatedAt); err != nil {
		return types.NewAppError(types.ErrCodeInternalDB, "failed to create forecast run", err)
	}
	return nil
}

// GetLatestServing returns the most recent forecast run with status 'complete'
// for the given model. This is the critical query for the forecast serving path
// (FQRY-001, FCST-005). It returns stale runs if no recent run exists, to
// support graceful degradation.
//
// SQL: SELECT * FROM forecast_runs WHERE model=$1 AND status='complete'
//
//	ORDER BY run_timestamp DESC LIMIT 1
//
// The query leverages the idx_forecast_runs_latest partial index.
//
// Returns nil (not an error) when no completed run exists for the model.
func (r *ForecastRunRepository) GetLatestServing(ctx context.Context, model types.ForecastType) (*types.ForecastRun, error) {
	row := r.db.QueryRow(ctx,
		`SELECT id, model, run_timestamp, source_data_timestamp, storage_path,
		        status, external_id, retry_count, failure_reason,
		        inference_duration_ms, created_at
		 FROM forecast_runs
		 WHERE model = $1 AND status = 'complete'
		 ORDER BY run_timestamp DESC
		 LIMIT 1`,
		string(model),
	)

	run, err := scanForecastRun(row)
	if err != nil {
		if errors.Is(err, pgx.ErrNoRows) {
			return nil, nil
		}
		return nil, types.NewAppError(types.ErrCodeInternalDB, "failed to query latest serving forecast run", err)
	}
	return run, nil
}

// MarkComplete transitions a forecast run to 'complete' status, recording the
// final storage path and inference duration. This is called after successful
// model inference.
func (r *ForecastRunRepository) MarkComplete(ctx context.Context, id string, storagePath string, durationMs int) error {
	tag, err := r.db.Exec(ctx,
		`UPDATE forecast_runs
		 SET status = 'complete', storage_path = $2, inference_duration_ms = $3
		 WHERE id = $1`,
		id,
		storagePath,
		durationMs,
	)
	if err != nil {
		return types.NewAppError(types.ErrCodeInternalDB, "failed to mark forecast run complete", err)
	}
	if tag.RowsAffected() == 0 {
		return types.NewAppError(types.ErrCodeInternalUnexpected, "forecast run not found: "+id, nil)
	}
	return nil
}

// MarkFailed transitions a forecast run to 'failed' status with a reason.
// Also increments the retry_count for recovery tracking (FCST-004).
func (r *ForecastRunRepository) MarkFailed(ctx context.Context, id string, reason string) error {
	tag, err := r.db.Exec(ctx,
		`UPDATE forecast_runs
		 SET status = 'failed', failure_reason = $2, retry_count = retry_count + 1
		 WHERE id = $1`,
		id,
		reason,
	)
	if err != nil {
		return types.NewAppError(types.ErrCodeInternalDB, "failed to mark forecast run as failed", err)
	}
	if tag.RowsAffected() == 0 {
		return types.NewAppError(types.ErrCodeInternalUnexpected, "forecast run not found: "+id, nil)
	}
	return nil
}

// UpdateExternalID updates the external tracking ID (e.g., RunPod Job ID) for
// a forecast run. Used when re-triggering a job to save the new external ID.
func (r *ForecastRunRepository) UpdateExternalID(ctx context.Context, id string, externalID string) error {
	tag, err := r.db.Exec(ctx,
		`UPDATE forecast_runs SET external_id = $2 WHERE id = $1`,
		id,
		externalID,
	)
	if err != nil {
		return types.NewAppError(types.ErrCodeInternalDB, "failed to update forecast run external ID", err)
	}
	if tag.RowsAffected() == 0 {
		return types.NewAppError(types.ErrCodeInternalUnexpected, "forecast run not found: "+id, nil)
	}
	return nil
}

// scanForecastRun scans a single forecast_runs row from a pgx.Row into a
// ForecastRun struct. Handles nullable columns (external_id, failure_reason,
// inference_duration_ms) using pointer types.
func scanForecastRun(row pgx.Row) (*types.ForecastRun, error) {
	var (
		run           types.ForecastRun
		model         string
		externalID    *string
		failureReason *string
		durationMS    *int
	)

	err := row.Scan(
		&run.ID,
		&model,
		&run.RunTimestamp,
		&run.SourceDataTimestamp,
		&run.StoragePath,
		&run.Status,
		&externalID,
		&run.RetryCount,
		&failureReason,
		&durationMS,
		&run.CreatedAt,
	)
	if err != nil {
		return nil, err
	}

	run.Model = types.ForecastType(model)
	if externalID != nil {
		run.ExternalID = *externalID
	}
	if failureReason != nil {
		run.FailureReason = *failureReason
	}
	if durationMS != nil {
		run.DurationMS = *durationMS
	}

	return &run, nil
}

// nilIfZeroInt returns nil if the value is zero, otherwise returns a pointer
// to the value. Used for nullable INTEGER columns.
func nilIfZeroInt(v int) *int {
	if v == 0 {
		return nil
	}
	return &v
}
